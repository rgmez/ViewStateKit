#!/usr/bin/env swift
import Foundation

/// Simple generator that scans `Sources/ViewStateKit/Resources/*.lproj/*.strings`
/// and emits a type-safe `L10n` Swift API mapping nested dot-separated
/// localization keys (e.g. "Empty.NoResults.Title") to computed
/// `String` properties that call the internal `localized(...)` helper.
///
/// Usage:
///  - `swift Tools/generate_localized_strings.swift` (writes to
///    `Sources/ViewStateKit/Generated/Strings+Localized.swift`)
///  - The script accepts an optional output path argument (used by the
///    SwiftPM plugin) to write the generated file to a custom location.

let fm = FileManager.default
let scriptURL = URL(fileURLWithPath: CommandLine.arguments[0]).deletingLastPathComponent()
let resourcesURL = scriptURL
    .appendingPathComponent("../Sources/ViewStateKit/Resources")
    .standardizedFileURL

// Allow optional output path as first argument (used by the plugin).
let outURLFromArg: URL? = CommandLine.arguments.count > 1 ? URL(fileURLWithPath: CommandLine.arguments[1]).standardized : nil
let outURL = outURLFromArg ?? scriptURL
    .appendingPathComponent("../Sources/ViewStateKit/Generated/Strings+Localized.swift")
    .standardizedFileURL

guard fm.fileExists(atPath: resourcesURL.path) else {
    fputs("Resources directory not found at \(resourcesURL.path)\n", stderr)
    exit(1)
}

/// Tree node representing nested key groups.
/// `children` maps intermediate group names to nested `Node`s.
/// `terminals` maps final key segments to the full localization key string.
class Node {
    var children: [String: Node] = [:]
    var terminals: [String: String] = [:]
}

/// Convert arbitrary `.strings` key fragments into a valid Swift identifier.
/// Replaces invalid chars with `_`, ensures it does not start with a digit,
/// and provides a fallback name when empty.
func sanitizeIdentifier(_ s: String) -> String {
    var out = s.replacingOccurrences(of: "[^0-9A-Za-z_]", with: "_", options: .regularExpression)
    if let first = out.first, first.isNumber {
        out = "_" + out
    }
    if out.isEmpty { out = "key" }
    return out
}

/// Lowercase the first character of a string. Used to create
/// idiomatic computed property names from title-cased keys.
func lowerFirst(_ s: String) -> String {
    guard let first = s.first else { return s }
    return String(first).lowercased() + s.dropFirst()
}

// Regex to capture "key" = "value"; entries in .strings files.
let keyRegex = try! NSRegularExpression(pattern: "\"([^\"]+)\"\\s*=\\s*\"(.*?)\";", options: [])
let root = Node()

// Walk resources and populate the node tree with keys.
let enumerator = fm.enumerator(at: resourcesURL, includingPropertiesForKeys: nil)!
for case let fileURL as URL in enumerator {
    if fileURL.pathExtension == "strings" {
        if let content = try? String(contentsOf: fileURL, encoding: .utf8) {
            let ns = content as NSString
            let matches = keyRegex.matches(in: content, options: [], range: NSRange(location: 0, length: ns.length))
            for m in matches {
                if m.numberOfRanges >= 2 {
                    let key = ns.substring(with: m.range(at: 1))
                    let parts = key.split(separator: ".").map(String.init)
                    var node = root
                    for (i, part) in parts.enumerated() {
                        if i == parts.count - 1 {
                            // terminal fragment — record full key
                            node.terminals[part] = key
                        } else {
                            if node.children[part] == nil {
                                node.children[part] = Node()
                            }
                            node = node.children[part]!
                        }
                    }
                }
            }
        }
    }
}

// Build the generated Swift source lines.
var lines: [String] = []
lines.append("// Generated by Tools/generate_localized_strings.swift — do not edit")
lines.append("import Foundation\n")
lines.append("public enum L10n {")

/// Recursive emitter that writes nested `enum` declarations for each node.
/// - Parameters:
///   - node: the current parse node
///   - name: Swift identifier for this enum
///   - indent: indentation string used for pretty output
func emit(node: Node, name: String, indent: String) {
    lines.append("\(indent)public enum \(name) {")
    // terminals -> computed properties
    let sortedTerms = node.terminals.keys.sorted()
    for term in sortedTerms {
        if let full = node.terminals[term] {
            let propName = lowerFirst(sanitizeIdentifier(term))
            lines.append("\(indent)    public static var \(propName): String { localized(\"\(full)\") }")
        }
    }
    // children -> nested enums
    let sortedChildren = node.children.keys.sorted()
    for child in sortedChildren {
        let childName = sanitizeIdentifier(child)
        emit(node: node.children[child]!, name: childName, indent: indent + "    ")
        // helper comment pointing to nested enum
        lines.append("\(indent)    // access nested values via L10n.\(name).\(childName)\\n")
    }
    lines.append("\(indent)}\n")
}

let topKeys = root.children.keys.sorted()
for top in topKeys {
    let node = root.children[top]!
    let topName = sanitizeIdentifier(top)
    emit(node: node, name: topName, indent: "    ")
}

lines.append("}\n")

// Ensure destination exists and write out the file.
try? fm.createDirectory(at: outURL.deletingLastPathComponent(), withIntermediateDirectories: true)
try lines.joined(separator: "\n").write(to: outURL, atomically: true, encoding: .utf8)
print("Generated \(outURL.path)")
